# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_loaders.ipynb.

# %% auto 0
__all__ = ['PDFLoader', 'DocumentBridge']

# %% ../nbs/05_loaders.ipynb 2
import PyPDF2
from pathlib import Path
from PyPDF2 import PdfReader
import random
from typing import List
import uuid
from PIL import Image
from io import BytesIO
import sys

# %% ../nbs/05_loaders.ipynb 3
from .store import *
from .base import *
from .context import *
from .llm import *

# %% ../nbs/05_loaders.ipynb 6
#For simplicity lets start with accepting a List. 
class PDFLoader:
    """Accepts a dir or single path and converts its contents into documents that can be later used for storage and retrieval"""
    def __init__(self, path_dir: str):
        self.path_dir = Path(path_dir)
        if self.path_dir.is_dir():
            self.paths = [path for path in self.path_dir.iterdir() if path]
        else:
            self.paths = [self.path_dir]
        self.path = None
        
    def pdf_validator(self, path):
        """Tries to read the pdf and returns a Bool value with the result"""
        try:
            reader = PdfReader(path)
            return True
        except Exception as e:
            return False

    def load_random_pdf(self):
        """Load a random pdf from the dataset. It loads pdfs until a valid one is found"""
        valid_pdf_found = False
        while not valid_pdf_found:  # Continue until a valid PDF is found
            pdf_path = random.choice(self.paths)
            is_valid = self.pdf_validator(pdf_path)
            if is_valid:
                reader = PdfReader(pdf_path)
                valid_pdf_found = True
                self.path = pdf_path
                return reader
            else:
                pdf_path.unlink()
                self.paths.remove(pdf_path)  # Remove the invalid path from the list
        
        if not valid_pdf_found:
            return None
    def load_pdf(self, path):
        reader = PdfReader(path)
        self.path = path
        return reader
    
    def get_documents(self, path = None):
        """Get a List of Text Documents from a pdf Path."""
        documents = []
        #Extracting text and storing it in documents
        if path == None:
            reader = self.load_random_pdf()
        else:
            reader = self.load_pdf(path)
        for i, page in enumerate(reader.pages):
            params = {"metadata": {**{"page": i + 1}, **reader.metadata}, "text": page.extract_text()}
            if i == 0:
                title = reader.metadata.get('title', None)
                if title is None:
                    title = params['text'].split('\n')[0]        
            if title is not None:
                params["name"] = title
            doc = Document(**params)
            documents.append(doc)
        return documents
    def get_images(self, path = None):
        #Can add some metadata like what page and location was found on. 
        #Create Image Node with that kind of info. 
        if path == None:
            reader = self.load_random_pdf()
        else:
            reader = self.load_pdf(path)
        images = []
        for count, page in enumerate(reader.pages):
            for image_file_object in page.images:
                image = Image.open(BytesIO(image_file_object.data))
                images.append(image)
        return images

# %% ../nbs/05_loaders.ipynb 7
class DocumentBridge:
    """Class for connecting a list of documents into its corresponding Nodes and relationships"""
    def __init__(self, documents: List, context: ModelContext):
        if isinstance(documents, List):
            self.documents = documents
        else:
            raise "You have to include a List of documents"
        self.context = context
    def nodes(self, chunk_size = 1024) -> List[TextNode]:
        """Brige a series of Documents into nodes linked by the end and start of the prev and next document. Great for linking together complex docs with structure
        such as pages or other info extracted first on a Document basis."""
        doc_nodes_list = [doc.create_nodes_from_doc(self.context, chunk_size = chunk_size) for doc in self.documents]
        for i, node_list in enumerate(doc_nodes_list):
            if i == 0:
                node_list[-1].next_node = doc_nodes_list[i + 1][0].id
            else:
                if i < len(doc_nodes_list) - 1:
                    node_list[-1].next_node = doc_nodes_list[i + 1][0].id
                node_list[0].prev_node = doc_nodes_list[i - 1][-1].id
        nodes = [node for node_list in doc_nodes_list for node in node_list]
        return nodes
        
    def join(self) -> Document:
        """Bridges a series of Documents into a single document. Great for storing sub-documents into a single one. Keeps some metadata of the documents into one. """
        #Store metadata about length, pages etc. For the later processing to be better. Maybe metadata about where each page started and ended in terms of characters could be good. 
        #see tradeoffs between this and diff docs pointing to a single reference. 
        #In reality in the conversion to nodes all the info is kept. We can post-process there. 
        pass
